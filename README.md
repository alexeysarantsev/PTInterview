# PTInterview

 Особенности алгоритма

 1. Так как предусмотрен многопоточный режим, нам нужно кэшировать очередное посчитанное число, потому что за этим числом возможно скоро придут снова.
 2. На вход в сервис приходит только N-ное число. Чтобы посчитать F(N+1), нам нужно знать и F(N-1). Мы не можем просто так получить F(N-1) зная F(N), значит F(N-1) на предыдущем рассчете. Для этого, получив в предыдущем рассчете F(N-2), мы должны посчитать и F(N-1) и закэшировать, чтобы быть готовым к приходу F(N)
 3. Мы не можем кэшировать бесконечно много чисел, нужен механизм очистки.
 4. Мы должны быть готовы к тому, что некоторые потоки могут "запаздывать". Мы не должны завязываться на то, что если мы получили F(N), то уже никогда не получим F(N-2)
 5. Есть несколько потоков вычисления. Если мы сейчас высчитываем F(N+1) по F(N), то получив еще раз F(N) нам нет смысла считать еще раз, результат будет тот же. Можно просто подождать, когда посчитает первый поток.

Реализация вычисления

Реализация вычисления находится в классе FiboCalculator (FiboApp2.Application.Services, FiboApp1.Application.Services). В сервисах реализация практически идентичная, не считая начальной инициализации.

Для кэширования результата (п.1) я использую ConcurrentDictionary<BigInteger, BigInteger>. Ключ - F(N), значение - F(N+1).

Для кэширования F(N-1) (п.2) я использую ConcurrentDictionary<BigInteger, BigInteger>. Ключ - F(N+2), значение - F(N+1).

Для хранения обработанных чисел, для которых мы что-то кэшировали, я использую ConcurrentQueue<BigInteger>. Когда размер очереди превышает некоторое значение, я очищаю как эту очередь, так и кэши, пока размер очереди не достигнет нужного значения.

Для реализации п.5 я использую ConcurrentDictionary<BigInteger, object>, где значение - это просто объект, по которому мы делаем lock. Я хотел использовать SemaphoreSlim (Wait/Release ) вместо lock, но не увидел преимуществ в скорости.

Если так получилось, что для F(N) нет посчитанного F(N-1), то будет вызван GetNextFromScratch, который быдет считать число с самого начала.

Реализация передачи данных
Как и оговаривалось в задании - первое приложение пишет во второе через web api, второе в первое - через RabbitMQ

Запуск

в проекте есть docker-compose.yml для запуска RabbitMq. Он должен быть запущен первым 
Затем запускается FiboApp2, в последнюю очередь - FiboApp1.
В appsettings.json проекта FiboApp1 есть настройка ParallelComputations определяющая количество параллельных потоков
FiboApp1 сразу, при запуске, отправляет первое число (0) во второй сервис.

